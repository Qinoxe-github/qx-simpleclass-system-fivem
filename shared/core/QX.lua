---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Absolute.
--- DateTime: 25/05/2022 09:08
---

QX = {};

QX.classes = {};

QX.Config = {
    debugImport = false,
    debugExport = false,
    orm = {
        debug = false,
        enabled = true,
    },
};

function QX.export(name,cb,cls)
    local n = name;
    local class = QX.generateObjectClass(n,cls);

    local clazz = {};

    setmetatable(clazz, { __index= class});


    Citizen.CreateThread(function()
        local cl = cb(clazz);
        QX.classes[n:lower()] = cl;
        QX.classes[n:lower()].canBeImport = true;
    end)
end

---@return QX.Object
function QX.generateObjectClass(n,parent)
    ---@class QX.Object
    local class = parent and parent or {};
    class.__index = class;
    class.__className = n;
    class.canBeImport = false;
    function class:constructor()

    end

    function class:new(...)
        local instance = {};
        setmetatable(instance, { __index = QX.classes[n:lower()] });
        instance:constructor(...);

        return instance;
    end

    function class:super(...)
        self.__parent:_constructor(...);
        for k,v in pairs(self.__parent) do
            if type(v) ~= "function" then
                self[k] = v;
            end
        end
    end

    if QX.Config.debugExport and QX.getGlobalConfig().debug then
        Console:info("^4"..n.."^3 exported");
    end
    return class;
end

function QX.singleton(name,cb)
    local n = name;
    local class = QX.generateObjectClass(n);

    local clazz = {};
    setmetatable(clazz, { __index= class});
    Citizen.CreateThread(function()

        local cl = cb(clazz);
        QX.classes[n:lower()] = cl;
        QX.classes[n:lower()] = cl:new();
        QX.classes[n:lower()].canBeImport = true;
    end)
end

---@param className string
function QX.import(className)
    local name = className:lower();
    local classImported = false;
    local nbTry = 0;
    if QX.Config.debugImport and QX.getGlobalConfig().debug then
        Console:info("^4Try to import Class "..name.."^3");
    end
    if (not QX.classes[name] or ( QX.classes[name] and not QX.classes[name].canBeImport)) then
        Citizen.CreateThread(function()
            while not QX.classes[name] or ( QX.classes[name] and not QX.classes[name].canBeImport) do
                Wait(100);
                nbTry = nbTry + 1;
                if nbTry > 50 then
                    suggestion = {};

                    for k ,v in pairs(QX.classes) do
                        if(string.find(k,name) and k ~= name and QX.classes[name] == nil) then
                            table.insert(suggestion,k);
                        end
                    end

                    Console:warn("Unable to import class "..name.. (#suggestion > 0 and " Suggestions: "..table.concat(suggestion,", ") or ""))
                    return;
                end
            end
            classImported = true;
        end)
    else
        classImported = true;
    end

    repeat Wait(10) until classImported;
    if QX.Config.debugImport and QX.getGlobalConfig().debug then
        Console:info("^4Class "..name.."^3 imported");
    end
    return QX.classes[name];
end

function QX.extends(name,classExtended,cb)
    Citizen.CreateThread(function()
        local parent = QX.import(classExtended);

        local test = setmetatable({}, { __index = parent});
        test.__parent = parent;
        test.__parent["_constructor"] = parent.constructor;
        test.__index = parent;
        test.__className = name;
        test.canBeImport = false;
        QX.export(name,cb,test);
    end)
end

function QX.run(cb)
    CreateThread(function()
        cb();
    end)
end

function QX.uuid()
    ---@type UUID
    local UUID = QX.import("UUID");
    return UUID:generate();
    --while not generate do  end
    --return generate;
    -- local template = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx';
    -- math.randomseed(os.time())
    -- local uuid = string.gsub(template, '[xy]', function (c)
    --     local v = (c == 'x') and math.random(0, 0xf) or math.random(8, 0xb);
    --     return string.format('%x', v);
    -- end);
    -- return uuid;
end

function QX.debugContext()
    for k,v in pairs(QX.classes) do
        Console:debug(k.." : "..v.__className,v);
    end
end


function QX.assign(className, object, ...)
    local cls = QX.classes[className:lower()];
    local obj = cls:new(...);
    for k,v in pairs(object) do
        obj[k] = v;
    end
    return obj;
end

function QX.initDatabase()
    for k,v in pairs(Repositories) do
        v:initData();
    end
end

function QX.getGlobalConfig()
    return Config;
end

function QX.getConfig()
    return QX.Config;
end

function QX.netEvent(name,cb)
    RegisterNetEvent(name, function(...)
        local src = source;
        --if IsDuplicityVersion() then
        --    ---@type ServiceManager
        --    local ServiceManager = QX.import("ServiceManager");
        --    local player = ServiceManager.playerService:getPlayerFromId(source);
        --    cb(player,...);
        --else
            cb(src,table.unpack({...}));
        --end

    end);
end

function QX.cloneObject(obj)
    local cloned = {};
    for k,v in pairs(obj) do
        cloned[k] = v;
    end
    return cloned;
end


function QX.emitNet(name,...)
    if IsDuplicityVersion() then
        local args = {...};
        local source = args[1];
        table.remove(args,1)
        TriggerClientEvent(name,source,table.unpack(args));
    else
        TriggerServerEvent(name,...);
    end
end

function QX.registerServerCallback(eventName, callback)
    if IsDuplicityVersion() then
        RegisterNetEvent(eventName);
        AddEventHandler(eventName, function(...)
            local src = source;
            local args = {...};
            local id = args[1];
            table.remove(args, 1);
            callback(src, function(...)
                local argsCallback = {...};
                TriggerClientEvent(eventName..":"..id, src, table.unpack(argsCallback));
            end, table.unpack(args));
        end);
    else
        Console:error("Unable to register server callback "..eventName.." on client");
    end
end

function QX.triggerServerCallback(eventName, cb, ...)
    if not IsDuplicityVersion() then
        local id = QX.uuid()
        TriggerServerEvent(eventName, id, ...);

        RegisterNetEvent(eventName..":".. id);
        local eventId;
        eventId = AddEventHandler(eventName.. ":".. id,function(...)
            cb(...);
            RemoveEventHandler(eventId);
        end);
    else
        Console:error("Unable to trigger server callback "..eventName.." on server");
    end
end

function QX.removeAllFunc(obj)
    local tab = {};

    for k,v in pairs(obj) do
        if(type(v) == "table") then
            tab[k] = QX.removeAllFunc(v);
        elseif type(v) ~= "function" then
            tab[k] = v;
        end
    end
    return tab;
end

function QX.registerCallback(eventName, callback)
    if not IsDuplicityVersion() then
        RegisterNetEvent(eventName);
        AddEventHandler(eventName, function(...)
            local args = {...};
            local id = args[1];
            table.remove(args, 1);
            callback(function(...)
                local argsCallback = {...};
                TriggerServerEvent(eventName..":"..id, table.unpack(argsCallback));
            end,table.unpack(args));
        end);
    else
        Console:error("Unable to register callback "..eventName.." on server");
    end
end

function QX.triggerCallback(eventName, source, cb, ...)
    if IsDuplicityVersion() then
        local id = QX.uuid()
        TriggerClientEvent(eventName, source, id, ...);

        RegisterNetEvent(eventName..":".. id);
        local eventId;
        eventId = AddEventHandler(eventName.. ":".. id,function(...)
            cb(...);
            RemoveEventHandler(eventId);
        end);
    else
        Console:error("Unable to trigger client callback "..eventName.." on client");
    end
end


---@param data table
function QX.sizeOf(data)
    local count = 0;
    for k,v in pairs(data) do
        count = count + 1;
    end
    return count;
end

function QX.isServer()
    return IsDuplicityVersion();
end

--- Map a table with a function
--- @param table table
--- @param func function
--- @return table
function table.map(table, func)
    local mapped = {}
    for k, v in pairs(table) do
        mapped[#mapped + 1] = func(k,v)
    end
    return mapped
end

Console:info("Context loaded");





